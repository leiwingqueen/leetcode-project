package wc368

// 给你一个字符串 s 和一个整数 k ，请你将 s 分成 k 个 子字符串 ，使得每个 子字符串 变成 半回文串 需要修改的字符数目最少。
//
//请你返回一个整数，表示需要修改的 最少 字符数目。
//
//注意：
//
//如果一个字符串从左往右和从右往左读是一样的，那么它是一个 回文串 。
//如果长度为 len 的字符串存在一个满足 1 <= d < len 的正整数 d ，len % d == 0 成立且所有对 d 做除法余数相同的下标对应的字符连起来得到的字符串都是 回文串 ，那么我们说这个字符串是 半回文串 。比方说 "aa" ，"aba" ，"adbgad" 和 "abab" 都是 半回文串 ，而 "a" ，"ab" 和 "abca" 不是。
//子字符串 指的是一个字符串中一段连续的字符序列。
//
//
//示例 1：
//
//输入：s = "abcac", k = 2
//输出：1
//解释：我们可以将 s 分成子字符串 "ab" 和 "cac" 。子字符串 "cac" 已经是半回文串。如果我们将 "ab" 变成 "aa" ，它也会变成一个 d = 1 的半回文串。
//该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 1 。
//示例 2:
//
//输入：s = "abcdef", k = 2
//输出：2
//解释：我们可以将 s 分成子字符串 "abc" 和 "def" 。子字符串 "abc" 和 "def" 都需要修改一个字符得到半回文串，所以我们总共需要 2 次字符修改使所有子字符串变成半回文串。
//该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 2 。
//示例 3：
//
//输入：s = "aabbaa", k = 3
//输出：0
//解释：我们可以将 s 分成子字符串 "aa" ，"bb" 和 "aa" 。
//字符串 "aa" 和 "bb" 都已经是半回文串了。所以答案为 0 。
//
//
//提示：
//
//2 <= s.length <= 200
//1 <= k <= s.length / 2
//s 只包含小写英文字母。

func minimumChanges(s string, k int) int {
	n := len(s)
	// 变成一个半回文串需要改变的最小的字符数量
	check := func(l, r int) int {
		size := r - l + 1
		res := size
		for d := 1; d < size; d++ {
			cnt := 0
			if size%d == 0 {
				// 遍历所有余数的下标
				for i := 0; i < d; i++ {
					p1, p2 := l+i, l+size-d+i
					for p1 < p2 {
						if s[p1] != s[p2] {
							cnt++
						}
						p1 += d
						p2 -= d
					}
				}
				if cnt < res {
					res = cnt
				}
			}
		}
		return res
	}
	dp := make([][]int, n+1)
	for i := 0; i <= n; i++ {
		dp[i] = make([]int, k+1)
	}
	for i := 2; i <= n; i++ {
		dp[i][1] = check(0, i-1)
	}
	for i := 3; i <= n; i++ {
		for j := 2; j <= i/2 && j <= k; j++ {
			dp[i][j] = n
			for l := 2; l <= i-2*(j-1); l++ {
				sub := dp[i-l][j-1] + check(i-l, i-1)
				if sub < dp[i][j] {
					dp[i][j] = sub
				}
			}
		}
	}
	return dp[n][k]
}
