package wc447

// 给你一个正整数数组 nums 和一个正整数 k。
//
// 当 nums 的一个 排列 中的所有数字，按照排列顺序 连接其十进制表示 后形成的数可以 被 k  整除时，我们称该排列形成了一个 可整除连接 。
//
// 返回能够形成 可整除连接 且 字典序 最小 的排列（按整数列表的形式表示）。如果不存在这样的排列，返回一个空列表。
//
// 示例 1：
//
// 输入: nums = [3,12,45], k = 5
//
// 输出: [3,12,45]
//
// 解释:
//
// 排列	连接后的值	是否能被 5 整除
// [3, 12, 45]	31245	是
// [3, 45, 12]	34512	否
// [12, 3, 45]	12345	是
// [12, 45, 3]	12453	否
// [45, 3, 12]	45312	否
// [45, 12, 3]	45123	否
// 可以形成可整除连接且字典序最小的排列是 [3,12,45]。
//
// 示例 2：
//
// 输入: nums = [10,5], k = 10
//
// 输出: [5,10]
//
// 解释:
//
// 排列	连接后的值	是否能被 10 整除
// [5, 10]	510	是
// [10, 5]	105	否
// 可以形成可整除连接且字典序最小的排列是 [5,10]。
//
// 示例 3：
//
// 输入: nums = [1,2,3], k = 5
//
// 输出: []
//
// 解释:
//
// 由于不存在任何可以形成有效可整除连接的排列，因此返回空列表。
//
// 提示：
//
// 1 <= nums.length <= 13
// 1 <= nums[i] <= 105
// 1 <= k <= 100

func concatenatedDivisibility(nums []int, k int) []int {
	// n := len(nums)
	/*var dfs func(offset int, idx int, mod int, expect int) []int
	dfs = func(offset int, idx int, mod int, expect int) []int {
		if idx == n {
			if mod == expect {
				res := make([]int, n)
				copy(res, nums)
				return res
			} else {
				return []int{}
			}
		}
		return []int{}
	}*/
	return []int{}
}
