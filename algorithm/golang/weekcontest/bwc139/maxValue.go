package bwc139

// 给你一个整数数组 nums 和一个 正 整数 k 。
//
// 定义长度为 2 * x 的序列 seq 的 值 为：
//
// (seq[0] OR seq[1] OR ... OR seq[x - 1]) XOR (seq[x] OR seq[x + 1] OR ... OR seq[2 * x - 1]).
// 请你求出 nums 中所有长度为 2 * k 的 子序列 的 最大值 。
//
// 示例 1：
//
// 输入：nums = [2,6,7], k = 1
//
// 输出：5
//
// 解释：
//
// 子序列 [2, 7] 的值最大，为 2 XOR 7 = 5 。
//
// 示例 2：
//
// 输入：nums = [4,2,5,6,7], k = 2
//
// 输出：2
//
// 解释：
//
// 子序列 [4, 5, 6, 7] 的值最大，为 (4 OR 5) XOR (6 OR 7) = 2 。
//
// 提示：
//
// 2 <= nums.length <= 400
// 1 <= nums[i] < 27
// 1 <= k <= nums.length / 2

// 某个位要为1，相当于前x个数字或为0，后x个数字至少有一个数字为1。或者反过来。也就是需要保证这一个bit不能全为0或者全为1
// 也就是等价于该位的所有数字&=0,|=1
func maxValue(nums []int, k int) int {
	return 0
}
