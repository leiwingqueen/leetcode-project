package wc479

import "sort"

// 给你一个整数数组 nums。
//
//二进制反射 是对一个 正整数 的二进制表示按顺序反转（忽略前导零）后，将反转得到的二进制数转为十进制的结果。
//
//请按每个元素的二进制反射值的 升序 对数组进行排序。如果两个不同的数字具有相同的二进制反射值，则 较小 的原始数字应排在前面。
//
//返回排序后的数组。
//
//
//
//示例 1：
//
//输入： nums = [4,5,4]
//
//输出： [4,4,5]
//
//解释：
//
//二进制反射值为：
//
//4 -> (二进制) 100 -> (反转) 001 -> 1
//5 -> (二进制) 101 -> (反转) 101 -> 5
//4 -> (二进制) 100 -> (反转) 001 -> 1
//根据反射值排序为 [4, 4, 5]。
//示例 2：
//
//输入： nums = [3,6,5,8]
//
//输出： [8,3,6,5]
//
//解释：
//
//二进制反射值为：
//
//3 -> (二进制) 11 -> (反转) 11 -> 3
//6 -> (二进制) 110 -> (反转) 011 -> 3
//5 -> (二进制) 101 -> (反转) 101 -> 5
//8 -> (二进制) 1000 -> (反转) 0001 -> 1
//根据反射值排序为 [8, 3, 6, 5]。
//注意，3 和 6 的反射值相同，因此需要按原始值的升序排列。
//
//
//提示：
//
//1 <= nums.length <= 100
//1 <= nums[i] <= 109

func sortByReflection(nums []int) []int {
	convert := func(num int) int {
		res := 0
		for num > 0 {
			res <<= 1
			res += num & 0b01
			num >>= 1
		}
		return res
	}
	sort.Slice(nums, func(i, j int) bool {
		c1, c2 := convert(nums[i]), convert(nums[j])
		if c1 != c2 {
			return c1 < c2
		} else {
			return nums[i] < nums[j]
		}
	})
	return nums
}
