package wc455

// 给你一个 从 1 开始计数 的整数数组 numWays，其中 numWays[i] 表示使用某些 固定 面值的硬币（每种面值可以使用无限次）凑出总金额 i 的方法数。每种面值都是一个 正整数 ，并且其值 最多 为 numWays.length。
//
//然而，具体的硬币面值已经 丢失 。你的任务是还原出可能生成这个 numWays 数组的面值集合。
//
//返回一个按从小到大顺序排列的数组，其中包含所有可能的 唯一 整数面值。
//
//如果不存在这样的集合，返回一个 空 数组。
//
//
//
//示例 1：
//
//输入： numWays = [0,1,0,2,0,3,0,4,0,5]
//
//输出： [2,4,6]
//
//解释：
//
//金额	方法数	解释
//1	0	无法用硬币凑出总金额 1。
//2	1	唯一的方法是 [2]。
//3	0	无法用硬币凑出总金额 3。
//4	2	可以用 [2, 2] 或 [4]。
//5	0	无法用硬币凑出总金额 5。
//6	3	可以用 [2, 2, 2]、[2, 4] 或 [6]。
//7	0	无法用硬币凑出总金额 7。
//8	4	可以用 [2, 2, 2, 2]、[2, 2, 4]、[2, 6] 或 [4, 4]。
//9	0	无法用硬币凑出总金额 9。
//10	5	可以用 [2, 2, 2, 2, 2]、[2, 2, 2, 4]、[2, 4, 4]、[2, 2, 6] 或 [4, 6]。
//示例 2：
//
//输入： numWays = [1,2,2,3,4]
//
//输出： [1,2,5]
//
//解释：
//
//金额	方法数	解释
//1	1	唯一的方法是 [1]。
//2	2	可以用 [1, 1] 或 [2]。
//3	2	可以用 [1, 1, 1] 或 [1, 2]。
//4	3	可以用 [1, 1, 1, 1]、[1, 1, 2] 或 [2, 2]。
//5	4	可以用 [1, 1, 1, 1, 1]、[1, 1, 1, 2]、[1, 2, 2] 或 [5]。
//示例 3：
//
//输入： numWays = [1,2,3,4,15]
//
//输出： []
//
//解释：
//
//没有任何面值集合可以生成该数组。
//
//
//
//提示：
//
//1 <= numWays.length <= 100
//0 <= numWays[i] <= 2 * 108

// 有点难
func findCoins(numWays []int) []int {
	n := len(numWays)
	var res []int
	// 找到第一个方法数>0的
	i := 1
	for ; i <= n; i++ {
		if numWays[i-1] > 0 {
			break
		}
	}
	if i > n || numWays[i-1] != 1 {
		return []int{}
	}
	res = append(res, i)
	expected := make([]int, n)
	for j := i; j <= n; j += i {
		expected[j-1] = 1
	}
	for j := i + 1; j <= n; j++ {
		if expected[j-1] == numWays[j-1] {
			continue
		}
		// 需要增加面值j
		if expected[j-1] != numWays[j-1]-1 {
			return []int{}
		}
		res = append(res, j)
		expected[j-1]++
		for k := j + 1; k <= n; k++ {
			expected[k-1] += expected[k-j-1]
		}
	}
	return res
}
