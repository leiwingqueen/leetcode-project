package graph

import "sort"

// leetcode submit region begin(Prohibit modification and deletion)
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	sort.Ints(initial)
	count := func(removeNode int) int {
		var queue []int
		visit := make([]bool, n)
		res := 0
		for _, node := range initial {
			if node != removeNode {
				queue = append(queue, node)
				visit[node] = true
				res++
			}
		}
		for len(queue) > 0 {
			size := len(queue)
			for _, node := range queue[:size] {
				for next, connect := range graph[node] {
					if connect == 1 && !visit[next] {
						queue = append(queue, next)
						visit[next] = true
						res++
					}
				}
			}
			queue = queue[size:]
		}
		return res
	}
	res := -1
	minCnt := n + 1
	for _, node := range initial {
		cnt := count(node)
		if cnt < minCnt {
			minCnt = cnt
			res = node
		}
	}
	return res
}

func minMalwareSpread3(graph [][]int, initial []int) int {
	n := len(graph)
	sort.Ints(initial)
	visit := make([]bool, n)
	initMap := make(map[int]struct{})
	for _, node := range initial {
		initMap[node] = struct{}{}
	}
	var dfs func(node int) (int, int)
	dfs = func(node int) (int, int) {
		if visit[node] {
			return 0, 0
		}
		visit[node] = true
		cnt1, cnt2 := 0, 1
		if _, ok := initMap[node]; ok {
			cnt1++
		}
		for next, connect := range graph[node] {
			if connect == 1 && !visit[next] {
				n1, n2 := dfs(next)
				cnt1 += n1
				cnt2 += n2
			}
		}
		return cnt1, cnt2
	}

	res := initial[0]
	maxCnt := 0
	for _, node := range initial {
		if !visit[node] {
			n1, n2 := dfs(node)
			if n1 == 1 && n2 < maxCnt {
				res = node
			}
		}
	}
	return res
}
