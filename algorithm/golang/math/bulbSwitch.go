package math

import "math"

// 初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
//
//第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
//
//找出并返回 n 轮后有多少个亮着的灯泡。
//
//
//
//示例 1：
//
//
//
//输入：n = 3
//输出：1
//解释：
//初始时, 灯泡状态 [关闭, 关闭, 关闭].
//第一轮后, 灯泡状态 [开启, 开启, 开启].
//第二轮后, 灯泡状态 [开启, 关闭, 开启].
//第三轮后, 灯泡状态 [开启, 关闭, 关闭].
//
//你应该返回 1，因为只有一个灯泡还亮着。
//示例 2：
//
//输入：n = 0
//输出：0
//示例 3：
//
//输入：n = 1
//输出：1
//
//
//提示：
//
//0 <= n <= 109

// 首先思考：灯泡i会被按几次？这其实相当于求i有几个因子 比如灯泡8,一共会被按4次，分别是第一轮 第二轮 第四轮 第八轮
//
// 一开始灯都是灭的，所以如果i有k个因子，且k为奇数，那么最终灯就亮，如果为偶数，灯就灭。 那么问题就转化成了，求1..n每个数分别有几个因子。 最直观的做法就是，枚举i，然后计算i的因子数。怎么计算呢？ 最直观的做法就是枚举j=0..i，count+= i%j==0 ? 1:0; 这里有个优化的点，假如x*y=z，显然z%y==0且z%x==0。 也就是说你只要需要枚举j从到1..根号i，count += i%j==0? 2:0;
//
// 在写完上面的式子之后你突然可以发现，在根号i的左边每发现一个j使得i%j==0，那么根号i的右边一定存在一个k同样满足i%k==0，一次枚举会把count+2。而我们关心的其实是最终count为奇数还是偶数！！通过枚举，count最终的结果都是偶数，当且仅当 i可以被开根号时，count才会是奇数！
//
// 然后其实问题转换成了，求数字1..n中有几个数能开更开得尽（结果是整数）
//
// 想到这里，你就可以一个O(n)的枚举来完成了吗？ 其实还可以优化！
//
// 想想，在1..n中，假设n等于100，1*1 2*2 3*3 4*4 ... 10*10的结果都小于等于100，换句话说，11 ... 根号n*根号n 都<= n，所以求1..n里有几个开根号能开尽的数，其实就是求根号n向下取整等于几。
//
// 所以最终答案就是 (n as f64).sqrt().floor() as i32
//
// 还能优化不？ 当然还可以！
//
// 求n开根号怎么求，有大量的论文可以参考，它们收敛速度能比语言自带的sqrt还快！！

// 这个题解牛逼
func bulbSwitch(n int) int {
	return int(math.Sqrt(float64(n) + 0.5))
}
