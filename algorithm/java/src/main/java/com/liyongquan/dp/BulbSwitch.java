package com.liyongquan.dp;

//灯泡开关
//初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。
//
//第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
//
//找出并返回 n 轮后有多少个亮着的灯泡。
//
// 
//
//示例 1：
//
//
//
//输入：n = 3
//输出：1
//解释：
//初始时, 灯泡状态 [关闭, 关闭, 关闭].
//第一轮后, 灯泡状态 [开启, 开启, 开启].
//第二轮后, 灯泡状态 [开启, 关闭, 开启].
//第三轮后, 灯泡状态 [开启, 关闭, 关闭].
//
//你应该返回 1，因为只有一个灯泡还亮着。
//示例 2：
//
//输入：n = 0
//输出：0
//示例 3：
//
//输入：n = 1
//输出：1
// 
//
//提示：
//
//0 <= n <= 109
//
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/bulb-switcher
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

/**
 * @author liyongquan
 * @date 2021/11/15
 */
public class BulbSwitch {
    /**
     * 先尝试简单的dp
     * <p>
     * 超时。时间复杂度O(n^2)
     *
     * @param n
     * @return
     */
    public int bulbSwitch(int n) {
        if (n == 0) {
            return 0;
        }
        int fn = 1;
        for (int i = 2; i <= n; i++) {
            int cnt = 0;
            //计算最后一个数字会变更多少次
            for (int j = 2; j <= i; j++) {
                if (i % j == 0) {
                    cnt++;
                }
            }
            fn = fn + (cnt % 2 == 0 ? 1 : 0);
        }
        return fn;
    }
}
